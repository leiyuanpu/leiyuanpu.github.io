<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F09%2F26%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041$arr = [11, 8, 43, 23, 10, 100];function quickSort($arr)&#123; $count = count($arr); if ($count &lt;= 1) &#123; return $arr; &#125; //选个轴 $comparedNum = $arr[0]; $smallList = $bigList = array(); for ($i = 1; $i &lt; $count; $i++) &#123; //小于对比数的放一起，大于的放一起 if ($arr[$i] &lt; $comparedNum) &#123; $smallList[] = $arr[$i]; &#125; else &#123; $bigList[] = $arr[$i]; &#125; &#125; $smallList = quickSort($smallList); $bigList = quickSort($bigList); return array_merge($smallList, array($comparedNum), $bigList);&#125;print_r(quickSort($arr)); //Array ( [0] =&gt; 8 [1] =&gt; 10 [2] =&gt; 11 [3] =&gt; 23 [4] =&gt; 43 [5] =&gt; 100 )//重点是理解这里的递归，这里可以举个例子：比如$arr = [2,1,4,3]// 1，第一次执行 $smallList[] = 1；$bigList = [4,3]// 2，调用quickSort($smallList，因为它只有一个元素)，函数会直接返回$smallList，因为它只有一个元素// 3，调用quickSort($bigList) 它会执行然后返回一个 array_merge合并后的数组 [3,4]// 3.1 因为这个时候$bigList有2个元素，于是它就会进入到for循环里，然后和对比数对比，照样分为$smallList和$bigList 两个数组，这个时候$smallList = [3];$bigList = [],然后继续分别调用 $smallList = quickSort($smallList); $bigList = quickSort($bigList); 但是这个时候他们分别为$smallList为1个元素，$bigList为0个元素，这时候// $count = count($arr);// if ($count &lt;= 1) &#123;// return $arr;// &#125;//这个条件将直接返回，不会再继续递归下去了。然后 array_merge 合并返回// 最后 3 这个步骤里调用的quickSort($bigList) 将会得到一个合并后的结果 [3,4]//最后在把 2 和 3的结果 和 选择的对比数($comparedNum),合并即得到我们最后的结果了。]]></content>
      <categories>
        <category>数据与结构</category>
      </categories>
      <tags>
        <tag>数据与结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序优化版]]></title>
    <url>%2F2019%2F09%2F26%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%E7%89%88%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920&lt;?php$num = [2, 1, 5, 3, 4, 9];$strlen = count($num);static $flage = true;for ($i = 0; $i &lt; $strlen &amp;&amp; $flage; $i++) &#123; $flage = false; for ($j = $strlen - 1; $j &gt; 0; $j--) &#123; if ($num[$j] &lt; $num[$j - 1]) &#123; $temp = $num[$j - 1]; $num[$j - 1] = $num[$j]; $num[$j] = $temp; $flage = true; &#125; &#125;&#125;print_r($num); //Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 [5] =&gt; 9 )]]></content>
      <categories>
        <category>数据与结构</category>
      </categories>
      <tags>
        <tag>数据与结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串反转算法]]></title>
    <url>%2F2019%2F09%2F24%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345678910111213141516&lt;?php$a = &apos;123abc123abc&apos;;$aLen = strlen($a);$revLen = floor($aLen / 2);for ($i = 0; $i &lt; $revLen; $i++) &#123; $temp = $a[$i]; $a[$i] = $a[$aLen - 1 - $i]; $a[$aLen - 1] = $temp;&#125;echo $a; //cba321123abc]]></content>
      <categories>
        <category>数据与结构</category>
      </categories>
      <tags>
        <tag>数据与结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串朴素的模式匹配算法]]></title>
    <url>%2F2019%2F09%2F24%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617&lt;?php$a = &apos;123abc123abc&apos;;$b = &apos;123&apos;;$aLen = strlen($a);$bLen = strlen($b);for ($i = 0; $i &lt; $aLen; $i++) &#123; for ($j = 0; $j &lt; $bLen; $j++) &#123; if ($b[$j] != $a[$i + $j]) &#123; //a和b只要有一位不相同，a则从匹配到下一位继续开始匹配。 break; &#125; &#125; if ($j == $bLen) &#123; echo &apos;ok&apos;; &#125;&#125;]]></content>
      <categories>
        <category>数据与结构</category>
      </categories>
      <tags>
        <tag>数据与结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostMan工具之tests项设置]]></title>
    <url>%2F2019%2F09%2F19%2FPostMan%E5%B7%A5%E5%85%B7%E4%B9%8Btests%E9%A1%B9%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1，获取API返回参数： 1var jsonData =JSON.parse(responseBody);//获取body中返回的所有参数 2，设置全局变量1postman.setGlobalVariable(&quot;Auth&quot;,jsonData.data.authToken);//把返回参数中的keys设置为环境变量 4，获取全局变量1postman.getGlobalVariable(&quot;Auth&quot;); 4，设置环境变量1postman.setEnvironmentVariable(&quot;key&quot;, &quot;value&quot;); 5，获取环境变量1postman.getEnvironmentVariable(&quot;key&quot;); 6，获取URL请求的cookie，并且设置到环境变量里1234pm.environment.set( &quot;XSRF-TOKEN&quot;, decodeURIComponent(pm.cookies.get(&quot;XSRF-TOKEN&quot;)))]]></content>
      <categories>
        <category>PostMan</category>
      </categories>
      <tags>
        <tag>PostMan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int（1）和int（10）的区别]]></title>
    <url>%2F2019%2F09%2F12%2Fint%EF%BC%881%EF%BC%89%E5%92%8Cint%EF%BC%8810%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[我们知道char(10),varchar(10)这种都是指占用多少个字节，比如用char(10)存储‘1234567890ab’,会被截断成’1234567890’,因为超过了指定长度10。 但是整形跟char、varchar不同，整形分为tinyint，smallint，mediumint，bigint 类型 字节 有符号最小值 有符号最大值 无符号最小值 无符号最大值 tinyint 1 -128 127 0 255 smallint 2 -32768 32767 0 65535 mediumint 3 -8388608 8388607 0 16777215 int 4 -2147483648 2147483647 0 16777215 bigint 8 -9223372036854775808 9223372036854775807 0 18446744073709551615 既然已经根据长度不同，内置了整形的不同类型，那么int(1)和int(11)有什么区别了？ $\color{red}{int(M)}$我们先来拆分，int是代表整型数据那么中间的M应该是代表多少位了，后来查mysql手册也得知了我的理解是正确的，下面我来举例说明。 MySQL 数据类型中的 integer types 有点奇怪。你可能会见到诸如：int(3)、int(4)、int(8) 之类的 int 数据类型。刚接触 MySQL 的时候，我还以为 int(3) 占用的存储空间比 int(4) 要小， int(4) 占用的存储空间比 int(8) 小。后来，参看 MySQL 手册，发现自己理解错了。 int(M): M indicates the maximum display width for integer types.1在 integer 数据类型中，M 表示最大显示宽度。 原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 btyes 的存储空间。说白了，除了显示给用户的方式有点不同外，int(M) 跟 int 数据类型是相同的。另外，int(M) 只有跟 zerofill 结合起来，才能使我们清楚的看到不同之处。 123456789101112131415161718192021222324252627282930313233mysql&gt; drop table if exists t;mysql&gt; create table t(id int zerofill);mysql&gt; insert into t(id) values(10);mysql&gt; select * from t;+------------+| id |+------------+| 0000000010 |+------------+mysql&gt; alter table t change column id id int(3) zerofill;mysql&gt; select * from t;+------+| id |+------+| 010 |+------+mysql&gt;mysql&gt; alter table t change column id id int(4) zerofill;mysql&gt; select * from t;+------+| id |+------+| 0010 |+------+mysql&gt;mysql&gt; insert into t(id) values(1000000);mysql&gt; select * from t;+---------+| id |+---------+| 0010 || 1000000 |+---------+ 从上面的测试可以看出，“(M)”指定了 int 型数值显示的宽度，如果字段数据类型是 int(4)，则：当显示数值 10 时，在左边要补上 “00”；当显示数值 100 是，在左边要补上“0”；当显示数值 1000000 时，已经超过了指定宽度“（4）”，因此按原样输出。 在使用 MySQL 数据类型中的整数类型（tinyint、smallint、 mediumint、 int/integer、bigint）时，非特殊需求下，在数据类型后加个“(M)”，是没有任何意义的。 int(1)和int(11)在实际使用中，如果不使用 zerofill 是没有任何区别的，而且int型最大只能存储4294967295这个整数，我们可以发现其实只有10位。 综上所述，当我们需要用整形来存储一个字段类型的时候，应该尽量估算出该字段所需要的实际长度，比如tinyint可存储无符号最大值是255（1个字节长度，即2的8次方），smallint可存储无符号最大值是65535（2个字节长度，即2的16次方），mediumint可存储无符号最大值是16777215（3个字节长度，即2的24次方），而int型最大可存储4294967295（3个字节长度，即2的32次方） 转载：https://helloape.com/article/22]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现单向链表详解]]></title>
    <url>%2F2019%2F09%2F09%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一，单向链表的简单示意 12345678头指针-》头节点-》节点-》节点-》NULL头指针：只保存指向头节点（第一个节点）的指针节点：数据域和指针域组成头节点: 数据域不存数据，指针域存指向第一个节点的指针NULL: 最后一个节点数直接后继指针，则指针为NULL注意：头指针必须有，而头结点可有可不有，加上头节点有利于处理节点问题 二，实现单向链表的重要几个步骤：123456789(1)创建节点，并且给当前节点数据结构配置定量的空间大小malloc反回的是指向该内存地址的指针，其中node 就是我们说的头指针 ep : struct list *node = malloc(sizeof(struct list));(2)清节点数据(由于结构体变量在未初始化的时候，数据是脏的) ep : memset(node,0,sizeof(struct list));(3)给节点初始化数据 ep : node-&gt;id = data ; (4)将该节点的指针域设置为NULL。这里说明我创建了一个头结点，即同时运用了头指针和头结点。 ep : node-&gt;next = NULL ; 三，具体实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct slist&#123; int id ; //数据区域 struct slist *next ; //指针区域 &#125;L; //定义的链表结构体从命名为 L //创建一个节点 L *create_node(int data)&#123; //给每个节点分配结构体一样的空间大小 //用malloc向计算机申请一块内存， //并定义一个指向与头节点数据类型相同的指针则定义LinkList L;时，L为链表的头指针。 L *p = (L *)malloc(sizeof(L)); if(NULL == p) &#123; printf(&quot;malloc error!\n&quot;); return NULL ; &#125; //由于结构体在未初始化的时候一样是脏数据，所以要清 memset(p,0,sizeof(L)); //初始化第一个节点 p-&gt;id = data ; //将节点的后继指针设置为NULL p-&gt;next = NULL ;&#125; //链表的尾插 *pH 为链表的最后一个指针，*newData 要插入的指针数据void tail_insert(L *pH, L *newData)&#123; //获取当前的位置 L *p = pH ; //如果当前位置的下一个节点不为空 while(NULL != p-&gt;next) &#123; //移动到下一个节点 p = p-&gt;next ; &#125; //如果跳出以上循环，所以已经到了NULL的这个位置 //此时直接把新插入的节点赋值给NULL这个位置 p-&gt;next = newData ;&#125;//链表的头插 void top_insert(L *pH , L *newData)&#123; L *p = pH ; newData-&gt;next = p-&gt;next ; p-&gt;next = newData ;&#125; //链表的遍历 void Print_node(L *pH)&#123; //获取当前的位置 L *p = pH ; //获取第一个节点的位置 p = p-&gt;next ; //如果当前位置的下一个节点不为空 while(NULL != p-&gt;next) &#123; //(1)打印节点的数据 printf(&quot;id:%d\n&quot;,p-&gt;id); //(2)移动到下一个节点,如果条件仍为真，则重复(1)，再(2) p = p-&gt;next ; &#125; //如果当前位置的下一个节点为空，则打印数据 //说明只有一个节点 printf(&quot;id:%d\n&quot;,p-&gt;id);&#125;//删除链表中的节点 int detele_list_node(L * pH , int data)&#123; //获取当前头节点的位置 L *p = pH ; L *prev = NULL; while(NULL != p-&gt;next) &#123; //保存当前节点的前一个节点的指针 prev = p ; //然后让当前的指针继续往后移动 p = p-&gt;next ; //判断，找到了要删除的数据 if(p-&gt;id == data) &#123; //两种情况，一种是普通节点，还有一种是尾节点 if(p-&gt;next != NULL) //普通节点的情况 &#123; prev-&gt;next = p-&gt;next ; free(p); &#125; else //尾节点的情况 &#123; prev-&gt;next = NULL ; //将这个尾节点的上一个节点的指针域指向空 free(p); &#125; return 0 ; &#125; &#125; printf(&quot;没有要删除的节点\n&quot;); return -1 ;&#125; int main(int argc , char **argv) &#123; //创建第一个节点 int i ; L *header = create_node(0); for(i = 1 ; i &lt; 10 ; i++) &#123; top_insert(header,create_node(i)); &#125; Print_node(header); detele_list_node(header,5); putchar(&apos;\n&apos;); Print_node(header); return 0 ;&#125;//打印的结果：/*id:9id:8id:7id:6id:5id:4id:3id:2id:1id:9id:8id:7id:6id:4id:3id:2id:1*/ 参考：https://blog.csdn.net/morixinguan/article/details/68951912结构之美：http://www.nowamagic.net/librarys/veda/detail/1805]]></content>
      <categories>
        <category>数据与结构</category>
      </categories>
      <tags>
        <tag>数据与结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的后期静态绑定static]]></title>
    <url>%2F2019%2F09%2F02%2FPHP%E7%9A%84%E5%90%8E%E6%9C%9F%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9Astatic%2F</url>
    <content type="text"><![CDATA[自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。 当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。 所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。该功能从语言内部角度考虑被命名为“后期静态绑定”。 “后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。 上面是PHP文档里对后期静态绑定的解释里面有几个重点：1，后期静态绑定原理是存储了在上一个”非转发调用”的类名。2，转发调用是通过self::，parent::，static:: 以及 forward_static_call()实现的3，static::不再被解析为方法的当前类，而是通过实际运算计算出来的。4，当进行静态方法调用时，该类名即为明确指定的那个 如（C::getName）类名就是C5，；当进行非静态方法调用时，即为该对象所属的类 如($this-&gt;getName)类 这时候指的应该是$this所属的实例化对象。 转发调用 : 指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。非转发调用 ： 明确指定类名的静态调用（例如A::test()）非静态调用（例如$A-&gt;test()） 场景一：1234567891011121314151617class A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); // 后期静态绑定从这里开始 &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test(); //B分析：B::test时A类的test方法会通过 static::who 进修转发调用，这时候static::指向的是B类而不是A类 场景二123456789101112131415161718192021222324252627282930313233class A &#123; private function foo() &#123; echo &quot;success!\n&quot;; &#125; public function test() &#123; $this-&gt;foo(); static::foo(); &#125;&#125;class B extends A &#123; /* foo() will be copied to B, hence its scope will still be A and * the call be successful */&#125;class C extends A &#123; private function foo() &#123; /* original method is replaced; the scope of the new one is C */ &#125;&#125;$b = new B();$b-&gt;test();输出：success!success!$c = new C();$c-&gt;test(); //fails输出：success!Fatal error: Call to private method C::foo() from context &apos;A&apos; in /tmp/test.php on line 9 总结：在非静态环境下，所调用的类即为该对象实例所属的类。由于 $this-&gt; 会在同一作用范围内尝试调用私有方法（即A类中的foo方法），而 static:: 则可能给出不同结果会转发调用（这时候会调用到C中的foo方法，由于它是私有的于是报错）。另一个区别是 static:: 只能用于静态属性。 场景三：12345678910111213141516171819202122232425262728class A &#123; public static function foo() &#123; static::who(); &#125; public static function who() &#123; echo __CLASS__.&quot;\n&quot;; &#125;&#125;class B extends A &#123; public static function test() &#123; A::foo(); parent::foo(); self::foo(); &#125; public static function who() &#123; echo __CLASS__.&quot;\n&quot;; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__.&quot;\n&quot;; &#125;&#125;C::test();//A C C 总结：后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 parent:: 或者 self:: 将转发调用信息，如上面场景三，他最终实际上转发给了C这个类。static关键字最终先会转发到他第一个调用的类（如这里的C），然后再一层层的往上找，假如这时候把C中的who方法注释，这时候结果就会变成（ABB）。 获取实例化对象的使用self和static的对比1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Base&#123; private static $instance; public $name; public static function getInstance() &#123; $class = get_called_class(); //动态获取调用类 if (!isset(self::$instance[$class])) &#123; self::$instance[$class] = new self(); //获取的当前类即base类 &#125; return self::$instance[$class]; &#125;&#125;class A extends Base&#123; public function who() &#123; return __class__; &#125;&#125;class B extends Base&#123; public function who() &#123; return __class__; &#125;&#125;var_dump(A::getInstance()); //// D:\www\my_project\test\a.php:34:// object(Base)[1]// public &apos;name&apos; =&gt; nullvar_dump(B::getInstance());// D:\www\my_project\test\a.php:34:// object(Base)[1]// public &apos;name&apos; =&gt; null 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpclass Base&#123; private static $instance; public $name; public static function getInstance() &#123; $class = get_called_class(); //动态获取调用类 if (!isset(self::$instance[$class])) &#123; self::$instance[$class] = new static(); //由于转发调用所以会通过实际的调用计算来获取当前的对象 &#125; return self::$instance[$class]; &#125;&#125;class A extends Base&#123; public function who() &#123; return __class__; &#125;&#125;class B extends Base&#123; public function who() &#123; return __class__; &#125;&#125;//var_dump(A::getInstance()); //// D:\www\my_project\test\a.php:34:// object(A)[1]// public &apos;name&apos; =&gt; nullvar_dump(B::getInstance());// D:\www\my_project\test\a.php:38:// object(B)[2]// public &apos;name&apos; =&gt; null 上面可以发现当我们使用self的时候永远获取的都是Base这个类，而使用static的时候就可以动态的获取调用对象了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSR-2编码规范在Phpstorm中的使用]]></title>
    <url>%2F2019%2F08%2F26%2FPSR-2%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%9C%A8Phpstorm%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[目的：项目中使用PSR-2 的编码风格规范，来提升团队整体代码的可读性。PhpStorm版本：2018.3 ####让编辑器使用 PSR-2 标准1，打开PhpStorm的设置页（File-&gt;Setting或者Ctrl+Alt+s），到Code Style页PHP中选择风格为 PSR1/2 2、到Code Sniffer页，路径是Setting-&gt;Languages and Frameworks-&gt;PHP-&gt;Quality Tools-&gt;Code Sniffer，设置phpcs的路径 3、到Inspections页，路径Setting-&gt;Editor-&gt;Inspections，右侧的 PHP，勾选下面的两个 PHP，选择使用 PSR2 4、效果这样设置完毕代码风格基本符合PSR-2的代码规范了，如果不符合编辑器会自动提示 ####编辑器集成php-cs和php-cdf ######一、集成php-cdf ######二、集成php-cs配置说明(直接可以用)： 12345Program是你的 PHP 根目录下的文件，windows 是.bat文件Arguments是--standard=PSR2 &quot;$FileDir$/$FileName$&quot;，可以直接填Working directory是$ProjectFileDir$，也可以直接填 三、插件配置好以后，到Keymap中设置快捷键 ####四、使用效果 4.1 按刚刚设置的快捷键，这时候php-cs会检测你当前页的代码风格，有问题会输出来。 4.2 php-cdf修复结果。大功告成~~~~参考：https://qq52o.me/2460.html]]></content>
      <categories>
        <category>Phpstorm</category>
      </categories>
      <tags>
        <tag>Phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windown连接上vpn后，内网不能访问的解决方案]]></title>
    <url>%2F2019%2F08%2F23%2Fwindown%E8%BF%9E%E6%8E%A5%E4%B8%8Avpn%E5%90%8E%EF%BC%8C%E5%86%85%E7%BD%91%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近连接上公司的vpn后，发现内网的服务都访问不了，当断开的时候缺又都可以访问了，后来发现当本机连接上vpn后，系统会走vpn的网关去寻址，这时候当然反问不了了，这是只需要在路由哪里配置一个寻址的网关即可： 如我本地的网关是红色表示那个： 假设我需要反问的内网地址段是：10.10.0.0 配置的命令：12route -p add 10.10.0.0 mask 255.255.0.0 192.168.254.100 metric 1ok 查看路由表命令：route PRINT -4123456789101112131415161718192021222324===========================================================================Interface List 12...........................Flipwires 11...88 d7 f6 7d 6f 8d ......Realtek PCIe GbE Family Controller 1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #4 17...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #5===========================================================================IPv4 Route Table===========================================================================Active Routes:Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.254.100 192.168.112.100 286 0.0.0.0 0.0.0.0 On-link 172.31.185.182 16 10.10.0.0 255.255.0.0 192.168.254.100 192.168.112.100 31===========================================================================Persistent Routes: Network Address Netmask Gateway Address Metric 0.0.0.0 0.0.0.0 192.168.254.100 Default 0.0.0.0 0.0.0.0 192.168.254.100 Default 10.10.0.0 255.255.0.0 192.168.254.100 1===========================================================================可以看到我们刚刚新增的那个路由关系 这段话的意思是：10.10.0.0这个网段的网络都通过192.168.254.100这网关去寻找，这命令是永久路由，重启电脑命令不会丢失 不出意外这个时候你就可以在连接上vpn的同时又可以访问内网啦啦啦。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7简单安装配置Lamp]]></title>
    <url>%2F2019%2F08%2F21%2Fcentos7%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AELamp%2F</url>
    <content type="text"><![CDATA[1.安装apache 1.1[root@localhost ~]# yum install httpd 根据提示，输入Y安装即可成功安装 1.2 systemctl start httpd.service #启动apache systemctl stop httpd.service #停止apache systemctl restart httpd.service #重启apache systemctl enable httpd.service #设置apache开机启动 centos7修改具体的apache配置 在etc/httpd/conf/httpd.conf目录下， 2.安装mariadb（MySQL）操作和mysql一样 yum install mariadb mariadb-server #安装mariadb 询问是否要安装，输入Y即可自动安装,直到安装完成 systemctl start mariadb.service #启动MariaDB, systemctl stop mariadb.service #停止MariaDB systemctl restart mariadb.service #重启MariaDB, systemctl enable mariadb.service #设置开机启动 3 如果需要安装mysql需要去官网下载 3.1.下载 wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 3.2.rpm 安装 mysql 相应的 yum源： rpm -uvh mysql-community-release-el7-5.noarch.rpm 3.3.安装mysql yum install mysql-community-server 3.4.成功安装之后重启mysql服务 service mysqld restart 3.5 mysql -u root -p 进入mysql 默认密码为空 3.6 mysql&gt; set password for ‘root’@‘localhost’ = password(‘mypasswd’); mysql&gt; exit 搞定！ (修改密码时可能会报错：Error (1133): Can’t find any matching row in the user table) 在mysql命令行中执行 FLUSH PRIVILEGES //刷新 grant all on *.* to root identified by &apos;root&apos;; //远程连接语句 4.安装Php（由于yum自带的php包版本过低，可选择删除重新安装） 4.1.删除旧版本 yum remove php* php-common 4.2.rpm 安装 Php7 相应的 yum源：rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 提示错误： error: Failed dependencies: epel-release &gt;= 7 is needed by webtatic-release-7-3.noarch 需要先安装epel-release。 1.安装epel-release 通过命令： yum -y install epel-release 成功安装。 4.3.安装phpyum install php70w 4.4.重启apache systemctl restart httpd.service 4.5.写一个php文件 vi /var/www/html/info.php 4.6 输入本机IP/info.php，显示phpinfo信息，至此apache，php OK了 php常用模块（php70w-fpm nginx解析php的容器）这里安装了 后面安装nignx时 直接调用就可以了 yum -y install php70w-devel php70w.x86_64php70w-cli.x86_64php70w-common.x86_64php70w-gd.x86_64php70w-ldap.x86_64php70w-mbstring.x86_64php70w-mcrypt.x86_64php70w-pdo.x86_64php70w-mysqlnd php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo 安装常用模块 5,安装nginx和php-fpm yum install -y nginx #设置nginx开机启动 systemctl enable nginx #设置php-fpm开机启动 systemctl enable php-fpm 提示： 1，之前自己安装的时候没有注意php的版本，apache安装成功了但是却不能解析php文件后面发现apache里没有加载php_module， 可以使用httpd-M检查是否安装，有则代表安装过。然后安装php7安装的时候自动就加上了，可能是版本过低的原因吧~~ 2，如果是阿里云服务器有可能你的数据库一直连接不上，这时你应该检查下你阿里云服务器的安全组接口是否开启，3306这个端口是否添加到安全组规则里 3，yum install –enablerepo=remi –enablerepo=remi-php56 php-fpm 安装php-fpm 进程管理器 4,如果安装好了 环境 执行php文件 报403错误 看看nginx.conf配置文件里 有没有指定index.php 如 ：location / { # root html; index index.html index.htm index.php; } 5，如果安装完执行php文件 页面显示为空白的话打开php.ini的： short_open_tag = On 6，如果防火墙开启的记得把端口加入到防火墙列表列如： 把 httpd 80端口加入到防火墙 firewall-cmd –zone=public –add-port=80/tcp –permanent –zone : 在什么域添加 –add-port:添加的端口号 –permanent:永久添加模式 参考文章： https://segmentfault.com/a/1190000009012613 http://www.cnblogs.com/rrrena/p/7228826.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore和excludes的区别]]></title>
    <url>%2F2019%2F08%2F20%2Fgitignore%E5%92%8Cexcludes%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、关于.gitignore 和 excludes这两个文件的只针对尚未提交到配置库的文件才起作用。而对于已经提交的文件是不起作用的。由此可见，这两个文件的初衷是用于排除不希望上传入库的文件。像编译产生的临时文件等。 但是，我们经常有这样一种情况。有个文件，我们必须入库，大家一起共享，但是呢。每个人本地的配置又是因自己本地的环境而异。这样的话，这个文件就很崩溃了。你要入库，通过.gitignore和excludes都不起作用。每次git status都会提示你修改，你又好上传。 对于这种情况，应该使用下面的命令：1git update-index --assume-unchanged FILENAME 这样，每个人，从库上取代码后，在自己本地都要执行一下上面的这个命令。这样，以后，你这个文件的修改，git 都会帮你忽略掉。 当然，哪一天，你希望你的修改要提交入库，那你也必须手动修改一下 这个文件的标志位： 1git update-index --no-assume-unchanged FILENAME]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[update方法使用集合]]></title>
    <url>%2F2019%2F08%2F16%2Fupdate%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[update应该是mysql里最常用的sql之一了，在开发过程中总结了以下几种写法 1,简单类型 1234语句结构update table set where示例：update product SET order_count = 2 WHERE id = 1 2,多表类型 1234语句结构update table1,table2 set table1.col = table2.col where 示例：update product as p,`order` as o SET p.id = o.product_id WHERE id = 1 3,子查询类型12345678 语句结构 update table1,(select * from table) a set table1.col = a.col 示例： UPDATE product as p, ( SELECT count( order_id ) AS order_count FROM `order` WHERE product_id = 1 ) AS o SET p.order_count = o.order_count WHEREid = 1]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取出分组后最新的一条数据的坑]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%8F%96%E5%87%BA%E5%88%86%E7%BB%84%E5%90%8E%E6%9C%80%E6%96%B0%E7%9A%84%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天群里有个小伙伴提了个需求说帮写一条取出分组后最新的一条数据的sql:123456789101112一开始我直接就上sql：select * from (select * from a order by a.id desc) t group by id 结果找到的数据老不对，后面查阅资源发现，在mysql5.7后 优化器默认过滤了查询的order by 效果，所以找到的数据不对劲，但是sql变成： select * from (select * from a order by a.id desc limit 9999) t group by id 却又可以了。后来只能用另外一种方法解决了，子查询加inner join 示例：select * from product INNER JOIN (select max(id) max_id from product group by price) as t on t.max_id = product.id order by id desc 最后问题解决~~]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载文件之Header方式下载]]></title>
    <url>%2F2019%2F08%2F13%2F%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E4%B9%8BHeader%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930/** * @param string $filePath 文件下载 * * @throws \Exception */public function fileDownload($filePath)&#123; if (file_exists($filePath) == false) &#123; throw new \Exception(&apos;文件不存在&apos;); &#125; $filename = basename($filePath); //获取文件名 header(&quot;Content-type: application/octet-stream&quot;); //告诉浏览器这是一个文件流 //处理中文文件名 $ua = $_SERVER[&quot;HTTP_USER_AGENT&quot;]; $encoded_filename = rawurlencode($filename); if (preg_match(&quot;/MSIE/&quot;, $ua)) &#123; header(&apos;Content-Disposition: attachment; filename=&quot;&apos; . $encoded_filename . &apos;&quot;&apos;); &#125; else &#123; if (preg_match(&quot;/Firefox/&quot;, $ua)) &#123; header(&quot;Content-Disposition: attachment; filename*=\&quot;utf8&apos;&apos;&quot; . $filename . &apos;&quot;&apos;); &#125; else &#123; header(&apos;Content-Disposition: attachment; filename=&quot;&apos; . $filename . &apos;&quot;&apos;); &#125; &#125; readfile($filePath);//将缓冲区的数据写入表格 //让Xsendfile发送文件 /// header(&quot;X-Sendfile: $filePath&quot;);&#125; header头参数详解：https://en.wikipedia.org/wiki/List_of_HTTP_header_fieldsXsendfile和readfile区别：http://www.laruence.com/2012/05/02/2613.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window自动开启redis服务]]></title>
    <url>%2F2019%2F08%2F13%2Fwindow%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AFredis%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1，检查服务是否开启 位置：控制面板\所有控制面板项\管理工具\服务 如果没有发现redis则代表 redis服务没有开启。 2，开启redis服务 redis-server --service-install redis.windows-service.conf --loglevel verbose 3，查看服务是否开启成功 大功告成。 常用命令： 卸载服务：redis-server --service-uninstall 开启服务：redis-server --service-start 停止服务：redis-server --service-stop 参考：https://blog.csdn.net/blick__winkel/article/details/77986481]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POSTMAN传递X-XSRF-TOKEN问题]]></title>
    <url>%2F2019%2F08%2F13%2FPOSTMAN%E4%BC%A0%E9%80%92X-XSRF-TOKEN%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当用PostMan去提交post请求时，laravel(luemn)框架会有XSRF的验证，目的在使用PostMan通过XSRF的验证，用于测试POST的请求。以Laravel为例，Laravel会于回应浏览器的GET请求时将XSRF-TOKEN写在cookie中，因此本篇将示范如何从cookie中取得XSRF-TOKEN并附在POST的头部传递出去 一，安装chrome的扩充功能 PostMan透过chrome为拦截器(Interceptor)来记录的cookie，因此要先安装PostMan在chrome的扩展。 网址：https：//chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo 二，在postMan扩展安装好后，新增一个开发环境 2.1 在postMan的右上角有个环境设置的选项 三，设置完之后选择刚刚建立的环境，然后执行一个get请求获取cookie3.1,把这段代码放入tests里 1234pm.environment.set( &quot;XSRF-TOKEN&quot;, decodeURIComponent(pm.cookies.get(&quot;XSRF-TOKEN&quot;))) 3.2，执行一个get请求查看下刚刚设置的环境，这是会有以下效果 3.3设置X-XSRF-TOKEN 3.4，执行一个post请求，完美执行成功]]></content>
      <categories>
        <category>PostMan</category>
      </categories>
      <tags>
        <tag>PostMan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP的flush和ob_flush的机制测试]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%85%B3%E4%BA%8EPHP%E7%9A%84flush%E5%92%8Cob-flush%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[12php正常的一个输出过高需要经历的阶段：echo/print -&gt; php buffer -&gt; tcp buffer -&gt; browser 一，buffer —- flush() buffer是一个内存地址空间,Linux系统默认大小一般为4096(1kb),即一个内存页。主要用于存储速度不同步的设备或者优先级不同的 设备之间传办理数据的区域。通过buffer，可以使进程这间的相互等待变少。这里说一个通俗一点的例子，你打开文本编辑器编辑一个文件的时候，你每输入 一个字符，操作系统并不会立即把这个字符直接写入到磁盘，而是先写入到buffer，当写满了一个buffer的时候，才会把buffer中的数据写入磁 盘，当然当调用内核函数flush()的时候，强制要求把buffer中的脏数据写回磁盘。同样的道理，当执行echo,print的时候，输出并没有立即通过tcp传给客户端浏览器显示, 而是将数据写入php buffer。php output_buffering机制，意味在tcp buffer之前，建立了一新的队列，数据必须经过该队列。当一个php buffer写满的时候，脚本进程会将php buffer中的输出数据交给系统内核交由tcp传给浏览器显示。 二，php output_buffering — ob_flush() 默认情况下，php buffer是开启的，而且该buffer默认值是4096，即1kb。你可以通过在php.ini配置文件中找到output_buffering配置.当echo,print等输出用户数据的时候，输出数据都会写入到php output_buffering中，直到output_buffering写满，会将这些数据通过tcp传送给浏览器显示。你也可以通过 ob_start()手动激活php output_buffering机制，使得即便输出超过了1kb数据，也不真的把数据交给tcp传给浏览器，因为ob_start()将php buffer空间设置到了足够大 。只有直到脚本结束，或者调用ob_end_flush函数，才会把数据发送给客户端浏览器。 这两个函数的使用怕是很多人最迷惑的一个问题，手册上对两个函数的解释也语焉不详，没有明确的指出它们的区别，似乎二者的功能都是刷新输出缓存。但在我们文章一开始的代码中如果讲fush()替换成ob_flush()，程序就再不能正确执行了。显然，它们是有区别的，否则也手册中直接说明其中一个是另外一个函数的别名即可了，没必要分别说明。那么它们的区别到底是什么呢？ 在没有开启缓存时，脚本输出的内容都在服务器端处于等待输出的状态 ，flush()可以将等待输出的内容立即发送到客户端。 开启缓存后，脚本输出的内容存入了输出缓存中 ，这时没有处于等待输出状态的内容，你直接使用flush()不会向客户端发出任何内容。而 ob_flush()的作用就是将本来存在输出缓存中的内容取出来，设置为等待输出状态，但不会直接发送到客户端 ，这时你就需要先使用 ob_flush()再使用flush()，客户端才能立即获得脚本的输出。 三，测试3.1，output_buffering=4096，输出较少的数据（少于一个buffer）123456&lt;?phpfor($i=0; $i&lt;10; $i++)&#123; echo $i.&apos;&lt;br&gt;&apos;; sleep(1);&#125;运行结果：等所有脚本全部运行完成后，才输出，因为数据未满一个buffer的大小。 3.2.output_buffering=4096，输出较少的数据（少于一个buffer），关闭output_buffering，修改php.ini的output_buffering=01234567&lt;?phpfor($i=0; $i&lt;10; $i++)&#123; echo $i.str_repeat(&quot;&amp;nbsp;&quot;,1000).&apos;&lt;br&gt;&apos;; // 为了浏览器能够显示 flush(); sleep(1);&#125;运行结果：因为禁用了php buffering，不需要等到脚本运行完毕就可以输出，数据没有在php buffer停留，可以看到断断续续间歇性输出。echo -&gt; tcp buffer -&gt;browser 参考博文：https://blog.csdn.net/fdipzone/article/details/10367837http://www.laruence.com/2010/04/15/1414.htmlhttps://www.cnblogs.com/zhangyuhang3/p/6873502.htmlhttp://niliu.me/articles/605.html#comment-2983]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPage简单的搭建实战]]></title>
    <url>%2F2019%2F08%2F02%2Fhexo-gitPage%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[###一，Hexo安装: 1.1，在命令行中通过 npm 来安装 Hexo： npm install -g hexo-cli -g 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。 Hexo 依赖于 [Node.js](https://nodejs.org/zh-cn/) 和 [git](https://git-scm.com/download/)，所以在安装 Hexo 之前先确保已安装了这两项应用。 1.2，根目录下执行初始化命令： hexo init 1.3，执行完毕： . ├── node_modules //依赖安装目录 ├── scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式 | ├── draft.md //草稿模板 | ├── page.md //页面模板 | └── post.md //文章模板 ├── source //资源文件夹，用于放置图片、数据、文章等资源 | └── _posts //文章目录 ├── themes //主题文件夹 | └── landscape //默认主题 ├── .gitignore //指定不纳入git版本控制的文件 ├── _config.yml //站点配置文件 ├── db.json ├── package.json └── package-lock.json 1.4，开启服务： hexo server hexo 服务器默认监听 4000 端口，用户可在浏览器中通过地址 localhost:4000 访问博客。 1.5，浏览器访问 localhost:4000 会将网站正常加载出来 ###二，gitpage页面搭建 2.1，创建一个项目例如 leiyuanpu.github.io //库名为自己的账号，等会这个就是我们访问的连接 2.2，点击项目的setting-&gt;设置GitHub Pages 选项1：Source //将master设置为站点的分支 选项2：Theme Chooser //选择主题 2.3，浏览器访问 如以上没有报错直接访问：leiyuanpu.github.io将会显示出一个完整的页面出来。 ###三，建hexo部署到git3.1 将hexo部署到git,并通过gitpage页面展示出来 在hexo项目里安装 npm install hexo-deployer-git --save 3.2 在根目录的_config.yml中设置： deploy: type: git repo: git@github.com:leiyuanpu/leiyuanpu.github.io.git //ssh模式 branch : master //master分支 3.3 设置免密码推送参考 https://www.jianshu.com/writer#/notebooks/21583544/notes/43946245/preview 3.4 基础命令 hexo clean 清除快取档案( db.json)和已产生的静态档案( public)。 hexo generate 产生静态档案。 hexo deploy 部署网站。 hexo help 会列出所有的命令 自己搭的效果示例：https://leiyuanpu.github.io/ 参考博客：http://yearito.cnhttps://linlif.github.io/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test111]]></title>
    <url>%2F2019%2F03%2F29%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
