<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[.gitignore和excludes的区别]]></title>
    <url>%2F2019%2F08%2F20%2Fgitignore%E5%92%8Cexcludes%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、关于.gitignore 和 excludes这两个文件的只针对尚未提交到配置库的文件才起作用。而对于已经提交的文件是不起作用的。由此可见，这两个文件的初衷是用于排除不希望上传入库的文件。像编译产生的临时文件等。 但是，我们经常有这样一种情况。有个文件，我们必须入库，大家一起共享，但是呢。每个人本地的配置又是因自己本地的环境而异。这样的话，这个文件就很崩溃了。你要入库，通过.gitignore和excludes都不起作用。每次git status都会提示你修改，你又好上传。 对于这种情况，应该使用下面的命令： git update-index –assume-unchanged FILENAME这样，每个人，从库上取代码后，在自己本地都要执行一下上面的这个命令。这样，以后，你这个文件的修改，git 都会帮你忽略掉。 当然，哪一天，你希望你的修改要提交入库，那你也必须手动修改一下 这个文件的标志位： git update-index –no-assume-unchanged FILENAME]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[update方法使用集合]]></title>
    <url>%2F2019%2F08%2F16%2Fupdate%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[update应该是mysql里最常用的sql之一了，在开发过程中总结了以下几种写法 1,简单类型 1234语句结构update table set where示例：update product SET order_count = 2 WHERE id = 1 2,多表类型 1234语句结构update table1,table2 set table1.col = table2.col where 示例：update product as p,`order` as o SET p.id = o.product_id WHERE id = 1 3,子查询类型12345678 语句结构 update table1,(select * from table) a set table1.col = a.col 示例： UPDATE product as p, ( SELECT count( order_id ) AS order_count FROM `order` WHERE product_id = 1 ) AS o SET p.order_count = o.order_count WHEREid = 1]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取出分组后最新的一条数据的坑]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%8F%96%E5%87%BA%E5%88%86%E7%BB%84%E5%90%8E%E6%9C%80%E6%96%B0%E7%9A%84%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天群里有个小伙伴提了个需求说帮写一条取出分组后最新的一条数据的sql:123456789101112一开始我直接就上sql：select * from (select * from a order by a.id desc) t group by id 结果找到的数据老不对，后面查阅资源发现，在mysql5.7后 优化器默认过滤了查询的order by 效果，所以找到的数据不对劲，但是sql变成： select * from (select * from a order by a.id desc limit 9999) t group by id 却又可以了。后来只能用另外一种方法解决了，子查询加inner join 示例：select * from product INNER JOIN (select max(id) max_id from product group by price) as t on t.max_id = product.id order by id desc 最后问题解决~~]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载文件之Header方式下载]]></title>
    <url>%2F2019%2F08%2F13%2F%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E4%B9%8BHeader%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930/** * @param string $filePath 文件下载 * * @throws \Exception */public function fileDownload($filePath)&#123; if (file_exists($filePath) == false) &#123; throw new \Exception(&apos;文件不存在&apos;); &#125; $filename = basename($filePath); //获取文件名 header(&quot;Content-type: application/octet-stream&quot;); //告诉浏览器这是一个文件流 //处理中文文件名 $ua = $_SERVER[&quot;HTTP_USER_AGENT&quot;]; $encoded_filename = rawurlencode($filename); if (preg_match(&quot;/MSIE/&quot;, $ua)) &#123; header(&apos;Content-Disposition: attachment; filename=&quot;&apos; . $encoded_filename . &apos;&quot;&apos;); &#125; else &#123; if (preg_match(&quot;/Firefox/&quot;, $ua)) &#123; header(&quot;Content-Disposition: attachment; filename*=\&quot;utf8&apos;&apos;&quot; . $filename . &apos;&quot;&apos;); &#125; else &#123; header(&apos;Content-Disposition: attachment; filename=&quot;&apos; . $filename . &apos;&quot;&apos;); &#125; &#125; readfile($filePath);//将缓冲区的数据写入表格 //让Xsendfile发送文件 /// header(&quot;X-Sendfile: $filePath&quot;);&#125; header头参数详解：https://en.wikipedia.org/wiki/List_of_HTTP_header_fieldsXsendfile和readfile区别：http://www.laruence.com/2012/05/02/2613.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window自动开启redis服务]]></title>
    <url>%2F2019%2F08%2F13%2Fwindow%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AFredis%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1，检查服务是否开启 位置：控制面板\所有控制面板项\管理工具\服务 如果没有发现redis则代表 redis服务没有开启。 2，开启redis服务 redis-server --service-install redis.windows-service.conf --loglevel verbose 3，查看服务是否开启成功 大功告成。 常用命令： 卸载服务：redis-server --service-uninstall 开启服务：redis-server --service-start 停止服务：redis-server --service-stop 参考：https://blog.csdn.net/blick__winkel/article/details/77986481]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POSTMAN传递X-XSRF-TOKEN问题]]></title>
    <url>%2F2019%2F08%2F13%2FPOSTMAN%E4%BC%A0%E9%80%92X-XSRF-TOKEN%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当用PostMan去提交post请求时，laravel(luemn)框架会有XSRF的验证，目的在使用PostMan通过XSRF的验证，用于测试POST的请求。以Laravel为例，Laravel会于回应浏览器的GET请求时将XSRF-TOKEN写在cookie中，因此本篇将示范如何从cookie中取得XSRF-TOKEN并附在POST的头部传递出去 一，安装chrome的扩充功能 PostMan透过chrome为拦截器(Interceptor)来记录的cookie，因此要先安装PostMan在chrome的扩展。 网址：https：//chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo 二，在postMan扩展安装好后，新增一个开发环境 2.1 在postMan的右上角有个环境设置的选项 三，设置完之后选择刚刚建立的环境，然后执行一个get请求获取cookie 3.1,把这段代码放入tests里 1234pm.environment.set( &quot;XSRF-TOKEN&quot;, decodeURIComponent(pm.cookies.get(&quot;XSRF-TOKEN&quot;))) 3.2，执行一个get请求查看下刚刚设置的环境，这是会有以下效果 3.3设置X-XSRF-TOKEN 3.4，执行一个post请求，完美执行成功]]></content>
      <categories>
        <category>PostMan</category>
      </categories>
      <tags>
        <tag>PostMan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP的flush和ob_flush的机制测试]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%85%B3%E4%BA%8EPHP%E7%9A%84flush%E5%92%8Cob-flush%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[12php正常的一个输出过高需要经历的阶段：echo/print -&gt; php buffer -&gt; tcp buffer -&gt; browser 一，buffer —- flush() buffer是一个内存地址空间,Linux系统默认大小一般为4096(1kb),即一个内存页。主要用于存储速度不同步的设备或者优先级不同的 设备之间传办理数据的区域。通过buffer，可以使进程这间的相互等待变少。这里说一个通俗一点的例子，你打开文本编辑器编辑一个文件的时候，你每输入 一个字符，操作系统并不会立即把这个字符直接写入到磁盘，而是先写入到buffer，当写满了一个buffer的时候，才会把buffer中的数据写入磁 盘，当然当调用内核函数flush()的时候，强制要求把buffer中的脏数据写回磁盘。同样的道理，当执行echo,print的时候，输出并没有立即通过tcp传给客户端浏览器显示, 而是将数据写入php buffer。php output_buffering机制，意味在tcp buffer之前，建立了一新的队列，数据必须经过该队列。当一个php buffer写满的时候，脚本进程会将php buffer中的输出数据交给系统内核交由tcp传给浏览器显示。 二，php output_buffering — ob_flush() 默认情况下，php buffer是开启的，而且该buffer默认值是4096，即1kb。你可以通过在php.ini配置文件中找到output_buffering配置.当echo,print等输出用户数据的时候，输出数据都会写入到php output_buffering中，直到output_buffering写满，会将这些数据通过tcp传送给浏览器显示。你也可以通过 ob_start()手动激活php output_buffering机制，使得即便输出超过了1kb数据，也不真的把数据交给tcp传给浏览器，因为ob_start()将php buffer空间设置到了足够大 。只有直到脚本结束，或者调用ob_end_flush函数，才会把数据发送给客户端浏览器。 这两个函数的使用怕是很多人最迷惑的一个问题，手册上对两个函数的解释也语焉不详，没有明确的指出它们的区别，似乎二者的功能都是刷新输出缓存。但在我们文章一开始的代码中如果讲fush()替换成ob_flush()，程序就再不能正确执行了。显然，它们是有区别的，否则也手册中直接说明其中一个是另外一个函数的别名即可了，没必要分别说明。那么它们的区别到底是什么呢？ 在没有开启缓存时，脚本输出的内容都在服务器端处于等待输出的状态 ，flush()可以将等待输出的内容立即发送到客户端。 开启缓存后，脚本输出的内容存入了输出缓存中 ，这时没有处于等待输出状态的内容，你直接使用flush()不会向客户端发出任何内容。而 ob_flush()的作用就是将本来存在输出缓存中的内容取出来，设置为等待输出状态，但不会直接发送到客户端 ，这时你就需要先使用 ob_flush()再使用flush()，客户端才能立即获得脚本的输出。 三，测试3.1，output_buffering=4096，输出较少的数据（少于一个buffer）123456&lt;?phpfor($i=0; $i&lt;10; $i++)&#123; echo $i.&apos;&lt;br&gt;&apos;; sleep(1);&#125;运行结果：等所有脚本全部运行完成后，才输出，因为数据未满一个buffer的大小。 3.2.output_buffering=4096，输出较少的数据（少于一个buffer），关闭output_buffering，修改php.ini的output_buffering=01234567&lt;?phpfor($i=0; $i&lt;10; $i++)&#123; echo $i.str_repeat(&quot;&amp;nbsp;&quot;,1000).&apos;&lt;br&gt;&apos;; // 为了浏览器能够显示 flush(); sleep(1);&#125;运行结果：因为禁用了php buffering，不需要等到脚本运行完毕就可以输出，数据没有在php buffer停留，可以看到断断续续间歇性输出。echo -&gt; tcp buffer -&gt;browser 参考博文：https://blog.csdn.net/fdipzone/article/details/10367837http://www.laruence.com/2010/04/15/1414.htmlhttps://www.cnblogs.com/zhangyuhang3/p/6873502.htmlhttp://niliu.me/articles/605.html#comment-2983]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPage简单的搭建实战]]></title>
    <url>%2F2019%2F08%2F02%2Fhexo-gitPage%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[###一，Hexo安装: 1.1，在命令行中通过 npm 来安装 Hexo： npm install -g hexo-cli -g 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。 Hexo 依赖于 [Node.js](https://nodejs.org/zh-cn/) 和 [git](https://git-scm.com/download/)，所以在安装 Hexo 之前先确保已安装了这两项应用。 1.2，根目录下执行初始化命令： hexo init 1.3，执行完毕： . ├── node_modules //依赖安装目录 ├── scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式 | ├── draft.md //草稿模板 | ├── page.md //页面模板 | └── post.md //文章模板 ├── source //资源文件夹，用于放置图片、数据、文章等资源 | └── _posts //文章目录 ├── themes //主题文件夹 | └── landscape //默认主题 ├── .gitignore //指定不纳入git版本控制的文件 ├── _config.yml //站点配置文件 ├── db.json ├── package.json └── package-lock.json 1.4，开启服务： hexo server hexo 服务器默认监听 4000 端口，用户可在浏览器中通过地址 localhost:4000 访问博客。 1.5，浏览器访问 localhost:4000 会将网站正常加载出来 ###二，gitpage页面搭建 2.1，创建一个项目例如 leiyuanpu.github.io //库名为自己的账号，等会这个就是我们访问的连接 2.2，点击项目的setting-&gt;设置GitHub Pages 选项1：Source //将master设置为站点的分支 选项2：Theme Chooser //选择主题 2.3，浏览器访问 如以上没有报错直接访问：leiyuanpu.github.io将会显示出一个完整的页面出来。 ###三，建hexo部署到git3.1 将hexo部署到git,并通过gitpage页面展示出来 在hexo项目里安装 npm install hexo-deployer-git --save 3.2 在根目录的_config.yml中设置： deploy: type: git repo: git@github.com:leiyuanpu/leiyuanpu.github.io.git //ssh模式 branch : master //master分支 3.3 设置免密码推送参考 https://www.jianshu.com/writer#/notebooks/21583544/notes/43946245/preview 3.4 基础命令 hexo clean 清除快取档案( db.json)和已产生的静态档案( public)。 hexo generate 产生静态档案。 hexo deploy 部署网站。 hexo help 会列出所有的命令 自己搭的效果示例：https://leiyuanpu.github.io/ 参考博客：http://yearito.cnhttps://linlif.github.io/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test111]]></title>
    <url>%2F2019%2F03%2F29%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
