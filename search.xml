<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PSR-2编码规范在Phpstorm中的使用]]></title>
    <url>%2F2019%2F08%2F26%2FPSR-2%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%9C%A8Phpstorm%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[目的：项目中使用PSR-2 的编码风格规范，来提升团队整体代码的可读性。PhpStorm版本：2018.3 ####让编辑器使用 PSR-2 标准1，打开PhpStorm的设置页（File-&gt;Setting或者Ctrl+Alt+s），到Code Style页PHP中选择风格为 PSR1/2! [hexo image] (1.png)! [hexo image] (/2.png) 2、到Code Sniffer页，路径是Setting-&gt;Languages and Frameworks-&gt;PHP-&gt;Quality Tools-&gt;Code Sniffer，设置phpcs的路径 3、到Inspections页，路径Setting-&gt;Editor-&gt;Inspections，右侧的 PHP，勾选下面的两个 PHP，选择使用 PSR2 4、效果这样设置完毕代码风格基本符合PSR-2的代码规范了，如果不符合编辑器会自动提示 ####编辑器集成php-cs和php-cdf ######一、集成php-cdf ######二、集成php-cs 配置说明： 12345Program是你的 PHP 根目录下的文件，windows 是.bat文件Arguments是$FileDir$/$FileName$，可以直接填Working directory是$ProjectFileDir$，也可以直接填 三、插件配置好以后，到Keymap中设置快捷键 ####四、使用效果 4.1 按刚刚设置的快捷键，这时候php-cs会检测你当前页的代码风格，有问题会输出来。 4.2 php-cdf修复结果。 大功告成~~~~参考：https://qq52o.me/2460.html]]></content>
      <categories>
        <category>Phpstorm</category>
      </categories>
      <tags>
        <tag>Phpstorm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windown连接上vpn后，内网不能访问的解决方案]]></title>
    <url>%2F2019%2F08%2F23%2Fwindown%E8%BF%9E%E6%8E%A5%E4%B8%8Avpn%E5%90%8E%EF%BC%8C%E5%86%85%E7%BD%91%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近连接上公司的vpn后，发现内网的服务都访问不了，当断开的时候缺又都可以访问了，后来发现当本机连接上vpn后，系统会走vpn的网关去寻址，这时候当然反问不了了，这是只需要在路由哪里配置一个寻址的网关即可： 如我本地的网关是红色表示那个： 假设我需要反问的内网地址段是：10.10.0.0 配置的命令：12route -p add 10.10.0.0 mask 255.255.0.0 192.168.254.100 metric 1ok 查看路由表命令：route PRINT -4123456789101112131415161718192021222324===========================================================================Interface List 12...........................Flipwires 11...88 d7 f6 7d 6f 8d ......Realtek PCIe GbE Family Controller 1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #4 17...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #5===========================================================================IPv4 Route Table===========================================================================Active Routes:Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.254.100 192.168.112.100 286 0.0.0.0 0.0.0.0 On-link 172.31.185.182 16 10.10.0.0 255.255.0.0 192.168.254.100 192.168.112.100 31===========================================================================Persistent Routes: Network Address Netmask Gateway Address Metric 0.0.0.0 0.0.0.0 192.168.254.100 Default 0.0.0.0 0.0.0.0 192.168.254.100 Default 10.10.0.0 255.255.0.0 192.168.254.100 1===========================================================================可以看到我们刚刚新增的那个路由关系 这段话的意思是：10.10.0.0这个网段的网络都通过192.168.254.100这网关去寻找，这命令是永久路由，重启电脑命令不会丢失 不出意外这个时候你就可以在连接上vpn的同时又可以访问内网啦啦啦。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7简单安装配置Lamp]]></title>
    <url>%2F2019%2F08%2F21%2Fcentos7%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AELamp%2F</url>
    <content type="text"><![CDATA[1.安装apache 1.1[root@localhost ~]# yum install httpd 根据提示，输入Y安装即可成功安装 1.2 systemctl start httpd.service #启动apache systemctl stop httpd.service #停止apache systemctl restart httpd.service #重启apache systemctl enable httpd.service #设置apache开机启动 centos7修改具体的apache配置 在etc/httpd/conf/httpd.conf目录下， 2.安装mariadb（MySQL）操作和mysql一样 yum install mariadb mariadb-server #安装mariadb 询问是否要安装，输入Y即可自动安装,直到安装完成 systemctl start mariadb.service #启动MariaDB, systemctl stop mariadb.service #停止MariaDB systemctl restart mariadb.service #重启MariaDB, systemctl enable mariadb.service #设置开机启动 3 如果需要安装mysql需要去官网下载 3.1.下载 wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 3.2.rpm 安装 mysql 相应的 yum源： rpm -uvh mysql-community-release-el7-5.noarch.rpm 3.3.安装mysql yum install mysql-community-server 3.4.成功安装之后重启mysql服务 service mysqld restart 3.5 mysql -u root -p 进入mysql 默认密码为空 3.6 mysql&gt; set password for ‘root’@‘localhost’ = password(‘mypasswd’); mysql&gt; exit 搞定！ (修改密码时可能会报错：Error (1133): Can’t find any matching row in the user table) 在mysql命令行中执行 FLUSH PRIVILEGES //刷新 grant all on *.* to root identified by &apos;root&apos;; //远程连接语句 4.安装Php（由于yum自带的php包版本过低，可选择删除重新安装） 4.1.删除旧版本 yum remove php* php-common 4.2.rpm 安装 Php7 相应的 yum源：rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 提示错误： error: Failed dependencies: epel-release &gt;= 7 is needed by webtatic-release-7-3.noarch 需要先安装epel-release。 1.安装epel-release 通过命令： yum -y install epel-release 成功安装。 4.3.安装phpyum install php70w 4.4.重启apache systemctl restart httpd.service 4.5.写一个php文件 vi /var/www/html/info.php 4.6 输入本机IP/info.php，显示phpinfo信息，至此apache，php OK了 php常用模块（php70w-fpm nginx解析php的容器）这里安装了 后面安装nignx时 直接调用就可以了 yum -y install php70w-devel php70w.x86_64php70w-cli.x86_64php70w-common.x86_64php70w-gd.x86_64php70w-ldap.x86_64php70w-mbstring.x86_64php70w-mcrypt.x86_64php70w-pdo.x86_64php70w-mysqlnd php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo 安装常用模块 5,安装nginx和php-fpm yum install -y nginx #设置nginx开机启动 systemctl enable nginx #设置php-fpm开机启动 systemctl enable php-fpm 提示： 1，之前自己安装的时候没有注意php的版本，apache安装成功了但是却不能解析php文件后面发现apache里没有加载php_module， 可以使用httpd-M检查是否安装，有则代表安装过。然后安装php7安装的时候自动就加上了，可能是版本过低的原因吧~~ 2，如果是阿里云服务器有可能你的数据库一直连接不上，这时你应该检查下你阿里云服务器的安全组接口是否开启，3306这个端口是否添加到安全组规则里 3，yum install –enablerepo=remi –enablerepo=remi-php56 php-fpm 安装php-fpm 进程管理器 4,如果安装好了 环境 执行php文件 报403错误 看看nginx.conf配置文件里 有没有指定index.php 如 ：location / { # root html; index index.html index.htm index.php; } 5，如果安装完执行php文件 页面显示为空白的话打开php.ini的： short_open_tag = On 6，如果防火墙开启的记得把端口加入到防火墙列表列如： 把 httpd 80端口加入到防火墙 firewall-cmd –zone=public –add-port=80/tcp –permanent –zone : 在什么域添加 –add-port:添加的端口号 –permanent:永久添加模式 参考文章： https://segmentfault.com/a/1190000009012613 http://www.cnblogs.com/rrrena/p/7228826.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitignore和excludes的区别]]></title>
    <url>%2F2019%2F08%2F20%2Fgitignore%E5%92%8Cexcludes%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、关于.gitignore 和 excludes这两个文件的只针对尚未提交到配置库的文件才起作用。而对于已经提交的文件是不起作用的。由此可见，这两个文件的初衷是用于排除不希望上传入库的文件。像编译产生的临时文件等。 但是，我们经常有这样一种情况。有个文件，我们必须入库，大家一起共享，但是呢。每个人本地的配置又是因自己本地的环境而异。这样的话，这个文件就很崩溃了。你要入库，通过.gitignore和excludes都不起作用。每次git status都会提示你修改，你又好上传。 对于这种情况，应该使用下面的命令：1git update-index --assume-unchanged FILENAME 这样，每个人，从库上取代码后，在自己本地都要执行一下上面的这个命令。这样，以后，你这个文件的修改，git 都会帮你忽略掉。 当然，哪一天，你希望你的修改要提交入库，那你也必须手动修改一下 这个文件的标志位： 1git update-index --no-assume-unchanged FILENAME]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[update方法使用集合]]></title>
    <url>%2F2019%2F08%2F16%2Fupdate%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[update应该是mysql里最常用的sql之一了，在开发过程中总结了以下几种写法 1,简单类型 1234语句结构update table set where示例：update product SET order_count = 2 WHERE id = 1 2,多表类型 1234语句结构update table1,table2 set table1.col = table2.col where 示例：update product as p,`order` as o SET p.id = o.product_id WHERE id = 1 3,子查询类型12345678 语句结构 update table1,(select * from table) a set table1.col = a.col 示例： UPDATE product as p, ( SELECT count( order_id ) AS order_count FROM `order` WHERE product_id = 1 ) AS o SET p.order_count = o.order_count WHEREid = 1]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取出分组后最新的一条数据的坑]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%8F%96%E5%87%BA%E5%88%86%E7%BB%84%E5%90%8E%E6%9C%80%E6%96%B0%E7%9A%84%E4%B8%80%E6%9D%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天群里有个小伙伴提了个需求说帮写一条取出分组后最新的一条数据的sql:123456789101112一开始我直接就上sql：select * from (select * from a order by a.id desc) t group by id 结果找到的数据老不对，后面查阅资源发现，在mysql5.7后 优化器默认过滤了查询的order by 效果，所以找到的数据不对劲，但是sql变成： select * from (select * from a order by a.id desc limit 9999) t group by id 却又可以了。后来只能用另外一种方法解决了，子查询加inner join 示例：select * from product INNER JOIN (select max(id) max_id from product group by price) as t on t.max_id = product.id order by id desc 最后问题解决~~]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载文件之Header方式下载]]></title>
    <url>%2F2019%2F08%2F13%2F%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E4%B9%8BHeader%E6%96%B9%E5%BC%8F%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930/** * @param string $filePath 文件下载 * * @throws \Exception */public function fileDownload($filePath)&#123; if (file_exists($filePath) == false) &#123; throw new \Exception(&apos;文件不存在&apos;); &#125; $filename = basename($filePath); //获取文件名 header(&quot;Content-type: application/octet-stream&quot;); //告诉浏览器这是一个文件流 //处理中文文件名 $ua = $_SERVER[&quot;HTTP_USER_AGENT&quot;]; $encoded_filename = rawurlencode($filename); if (preg_match(&quot;/MSIE/&quot;, $ua)) &#123; header(&apos;Content-Disposition: attachment; filename=&quot;&apos; . $encoded_filename . &apos;&quot;&apos;); &#125; else &#123; if (preg_match(&quot;/Firefox/&quot;, $ua)) &#123; header(&quot;Content-Disposition: attachment; filename*=\&quot;utf8&apos;&apos;&quot; . $filename . &apos;&quot;&apos;); &#125; else &#123; header(&apos;Content-Disposition: attachment; filename=&quot;&apos; . $filename . &apos;&quot;&apos;); &#125; &#125; readfile($filePath);//将缓冲区的数据写入表格 //让Xsendfile发送文件 /// header(&quot;X-Sendfile: $filePath&quot;);&#125; header头参数详解：https://en.wikipedia.org/wiki/List_of_HTTP_header_fieldsXsendfile和readfile区别：http://www.laruence.com/2012/05/02/2613.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window自动开启redis服务]]></title>
    <url>%2F2019%2F08%2F13%2Fwindow%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AFredis%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1，检查服务是否开启 位置：控制面板\所有控制面板项\管理工具\服务 如果没有发现redis则代表 redis服务没有开启。 2，开启redis服务 redis-server --service-install redis.windows-service.conf --loglevel verbose 3，查看服务是否开启成功 大功告成。 常用命令： 卸载服务：redis-server --service-uninstall 开启服务：redis-server --service-start 停止服务：redis-server --service-stop 参考：https://blog.csdn.net/blick__winkel/article/details/77986481]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POSTMAN传递X-XSRF-TOKEN问题]]></title>
    <url>%2F2019%2F08%2F13%2FPOSTMAN%E4%BC%A0%E9%80%92X-XSRF-TOKEN%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当用PostMan去提交post请求时，laravel(luemn)框架会有XSRF的验证，目的在使用PostMan通过XSRF的验证，用于测试POST的请求。以Laravel为例，Laravel会于回应浏览器的GET请求时将XSRF-TOKEN写在cookie中，因此本篇将示范如何从cookie中取得XSRF-TOKEN并附在POST的头部传递出去 一，安装chrome的扩充功能 PostMan透过chrome为拦截器(Interceptor)来记录的cookie，因此要先安装PostMan在chrome的扩展。 网址：https：//chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo 二，在postMan扩展安装好后，新增一个开发环境 2.1 在postMan的右上角有个环境设置的选项 三，设置完之后选择刚刚建立的环境，然后执行一个get请求获取cookie 3.1,把这段代码放入tests里 1234pm.environment.set( &quot;XSRF-TOKEN&quot;, decodeURIComponent(pm.cookies.get(&quot;XSRF-TOKEN&quot;))) 3.2，执行一个get请求查看下刚刚设置的环境，这是会有以下效果 3.3设置X-XSRF-TOKEN 3.4，执行一个post请求，完美执行成功]]></content>
      <categories>
        <category>PostMan</category>
      </categories>
      <tags>
        <tag>PostMan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP的flush和ob_flush的机制测试]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%85%B3%E4%BA%8EPHP%E7%9A%84flush%E5%92%8Cob-flush%E7%9A%84%E6%9C%BA%E5%88%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[12php正常的一个输出过高需要经历的阶段：echo/print -&gt; php buffer -&gt; tcp buffer -&gt; browser 一，buffer —- flush() buffer是一个内存地址空间,Linux系统默认大小一般为4096(1kb),即一个内存页。主要用于存储速度不同步的设备或者优先级不同的 设备之间传办理数据的区域。通过buffer，可以使进程这间的相互等待变少。这里说一个通俗一点的例子，你打开文本编辑器编辑一个文件的时候，你每输入 一个字符，操作系统并不会立即把这个字符直接写入到磁盘，而是先写入到buffer，当写满了一个buffer的时候，才会把buffer中的数据写入磁 盘，当然当调用内核函数flush()的时候，强制要求把buffer中的脏数据写回磁盘。同样的道理，当执行echo,print的时候，输出并没有立即通过tcp传给客户端浏览器显示, 而是将数据写入php buffer。php output_buffering机制，意味在tcp buffer之前，建立了一新的队列，数据必须经过该队列。当一个php buffer写满的时候，脚本进程会将php buffer中的输出数据交给系统内核交由tcp传给浏览器显示。 二，php output_buffering — ob_flush() 默认情况下，php buffer是开启的，而且该buffer默认值是4096，即1kb。你可以通过在php.ini配置文件中找到output_buffering配置.当echo,print等输出用户数据的时候，输出数据都会写入到php output_buffering中，直到output_buffering写满，会将这些数据通过tcp传送给浏览器显示。你也可以通过 ob_start()手动激活php output_buffering机制，使得即便输出超过了1kb数据，也不真的把数据交给tcp传给浏览器，因为ob_start()将php buffer空间设置到了足够大 。只有直到脚本结束，或者调用ob_end_flush函数，才会把数据发送给客户端浏览器。 这两个函数的使用怕是很多人最迷惑的一个问题，手册上对两个函数的解释也语焉不详，没有明确的指出它们的区别，似乎二者的功能都是刷新输出缓存。但在我们文章一开始的代码中如果讲fush()替换成ob_flush()，程序就再不能正确执行了。显然，它们是有区别的，否则也手册中直接说明其中一个是另外一个函数的别名即可了，没必要分别说明。那么它们的区别到底是什么呢？ 在没有开启缓存时，脚本输出的内容都在服务器端处于等待输出的状态 ，flush()可以将等待输出的内容立即发送到客户端。 开启缓存后，脚本输出的内容存入了输出缓存中 ，这时没有处于等待输出状态的内容，你直接使用flush()不会向客户端发出任何内容。而 ob_flush()的作用就是将本来存在输出缓存中的内容取出来，设置为等待输出状态，但不会直接发送到客户端 ，这时你就需要先使用 ob_flush()再使用flush()，客户端才能立即获得脚本的输出。 三，测试3.1，output_buffering=4096，输出较少的数据（少于一个buffer）123456&lt;?phpfor($i=0; $i&lt;10; $i++)&#123; echo $i.&apos;&lt;br&gt;&apos;; sleep(1);&#125;运行结果：等所有脚本全部运行完成后，才输出，因为数据未满一个buffer的大小。 3.2.output_buffering=4096，输出较少的数据（少于一个buffer），关闭output_buffering，修改php.ini的output_buffering=01234567&lt;?phpfor($i=0; $i&lt;10; $i++)&#123; echo $i.str_repeat(&quot;&amp;nbsp;&quot;,1000).&apos;&lt;br&gt;&apos;; // 为了浏览器能够显示 flush(); sleep(1);&#125;运行结果：因为禁用了php buffering，不需要等到脚本运行完毕就可以输出，数据没有在php buffer停留，可以看到断断续续间歇性输出。echo -&gt; tcp buffer -&gt;browser 参考博文：https://blog.csdn.net/fdipzone/article/details/10367837http://www.laruence.com/2010/04/15/1414.htmlhttps://www.cnblogs.com/zhangyuhang3/p/6873502.htmlhttp://niliu.me/articles/605.html#comment-2983]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPage简单的搭建实战]]></title>
    <url>%2F2019%2F08%2F02%2Fhexo-gitPage%E7%AE%80%E5%8D%95%E7%9A%84%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[###一，Hexo安装: 1.1，在命令行中通过 npm 来安装 Hexo： npm install -g hexo-cli -g 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。 Hexo 依赖于 [Node.js](https://nodejs.org/zh-cn/) 和 [git](https://git-scm.com/download/)，所以在安装 Hexo 之前先确保已安装了这两项应用。 1.2，根目录下执行初始化命令： hexo init 1.3，执行完毕： . ├── node_modules //依赖安装目录 ├── scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式 | ├── draft.md //草稿模板 | ├── page.md //页面模板 | └── post.md //文章模板 ├── source //资源文件夹，用于放置图片、数据、文章等资源 | └── _posts //文章目录 ├── themes //主题文件夹 | └── landscape //默认主题 ├── .gitignore //指定不纳入git版本控制的文件 ├── _config.yml //站点配置文件 ├── db.json ├── package.json └── package-lock.json 1.4，开启服务： hexo server hexo 服务器默认监听 4000 端口，用户可在浏览器中通过地址 localhost:4000 访问博客。 1.5，浏览器访问 localhost:4000 会将网站正常加载出来 ###二，gitpage页面搭建 2.1，创建一个项目例如 leiyuanpu.github.io //库名为自己的账号，等会这个就是我们访问的连接 2.2，点击项目的setting-&gt;设置GitHub Pages 选项1：Source //将master设置为站点的分支 选项2：Theme Chooser //选择主题 2.3，浏览器访问 如以上没有报错直接访问：leiyuanpu.github.io将会显示出一个完整的页面出来。 ###三，建hexo部署到git3.1 将hexo部署到git,并通过gitpage页面展示出来 在hexo项目里安装 npm install hexo-deployer-git --save 3.2 在根目录的_config.yml中设置： deploy: type: git repo: git@github.com:leiyuanpu/leiyuanpu.github.io.git //ssh模式 branch : master //master分支 3.3 设置免密码推送参考 https://www.jianshu.com/writer#/notebooks/21583544/notes/43946245/preview 3.4 基础命令 hexo clean 清除快取档案( db.json)和已产生的静态档案( public)。 hexo generate 产生静态档案。 hexo deploy 部署网站。 hexo help 会列出所有的命令 自己搭的效果示例：https://leiyuanpu.github.io/ 参考博客：http://yearito.cnhttps://linlif.github.io/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test111]]></title>
    <url>%2F2019%2F03%2F29%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
